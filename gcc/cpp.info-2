This is cpp.info, produced by makeinfo version 4.0 from cpp.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* Cpp: (cpp).		       The GNU C preprocessor.
END-INFO-DIR-ENTRY

   This file documents the GNU C Preprocessor.

   Copyright 1987, 1989, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
1999, 2000, 2001 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: cpp.info,  Node: Stringification,  Next: Concatenation,  Prev: Predefined,  Up: Macros

Stringification
---------------

   "Stringification" means turning a sequence of preprocessing tokens
into a string literal.  For example, stringifying `foo (z)' results in
`"foo (z)"'.

   In the C preprocessor, stringification is possible when macro
arguments are substituted during macro expansion.  When a parameter
appears preceded by a `#' token in the replacement list of a
function-like macro, it indicates that both tokens should be replaced
with the stringification of the corresponding argument during
expansion.  The same argument may be substituted in other places in the
definition without stringification if the argument name appears in
those places with no preceding `#'.

   Here is an example of a macro definition that uses stringification:

     #define WARN_IF(EXP) \
     do { if (EXP) \
             fprintf (stderr, "Warning: " #EXP "\n"); } \
     while (0)

Here the argument for `EXP' is substituted once, as-is, into the `if'
statement, and once, stringified, into the argument to `fprintf'.  The
`do' and `while (0)' are a kludge to make it possible to write `WARN_IF
(ARG);', which the resemblance of `WARN_IF' to a function would make C
programmers want to do; see *Note Swallow Semicolon::.

   The stringification feature is limited to transforming the tokens of
a macro argument into a string constant: there is no way to combine the
argument with surrounding text and stringify it all together.  The
example above shows how an equivalent result can be obtained in ISO
Standard C, using the fact that adjacent string constants are
concatenated by the C compiler to form a single string constant.  The
preprocessor stringifies the actual value of `EXP' into a separate
string constant, resulting in text like

     do { if (x == 0) \
             fprintf (stderr, "Warning: " "x == 0" "\n"); } \
     while (0)

but the compiler then sees three consecutive string constants and
concatenates them into one, producing effectively

     do { if (x == 0) \
             fprintf (stderr, "Warning: x == 0\n"); } \
     while (0)

   Stringification in C involves more than putting double-quote
characters around the fragment.  The preprocessor backslash-escapes the
surrounding quotes of string literals, and all backslashes within
string and character constants, in order to get a valid C string
constant with the proper contents.  Thus, stringifying `p = "foo\n";'
results in `"p = \"foo\\n\";"'.  However, backslashes that are not
inside string or character constants are not duplicated: `\n' by itself
stringifies to `"\n"'.

   Whitespace (including comments) in the text being stringified is
handled according to precise rules.  All leading and trailing
whitespace is ignored.  Any sequence of whitespace in the middle of the
text is converted to a single space in the stringified result.


File: cpp.info,  Node: Concatenation,  Next: Undefining,  Prev: Stringification,  Up: Macros

Concatenation
-------------

   "Concatenation" means joining two strings into one.  In the context
of macro expansion, concatenation refers to joining two preprocessing
tokens to form one.  In particular, a token of a macro argument can be
concatenated with another argument's token or with fixed text to produce
a longer name.  The longer name might be the name of a function,
variable, type, or a C keyword; it might even be the name of another
macro, in which case it will be expanded.

   When you define a function-like or object-like macro, you request
concatenation with the special operator `##' in the macro's replacement
list.  When the macro is called, any arguments are substituted without
performing macro expansion, every `##' operator is deleted, and the two
tokens on either side of it are concatenated to form a single token.

   Consider a C program that interprets named commands.  There probably
needs to be a table of commands, perhaps an array of structures
declared as follows:

     struct command
     {
       char *name;
       void (*function) ();
     };
     
     struct command commands[] =
     {
       { "quit", quit_command},
       { "help", help_command},
       ...
     };

   It would be cleaner not to have to give each command name twice,
once in the string constant and once in the function name.  A macro
which takes the name of a command as an argument can make this
unnecessary.  The string constant can be created with stringification,
and the function name by concatenating the argument with `_command'.
Here is how it is done:

     #define COMMAND(NAME)  { #NAME, NAME ## _command }
     
     struct command commands[] =
     {
       COMMAND (quit),
       COMMAND (help),
       ...
     };

   The usual case of concatenation is concatenating two names (or a name
and a number) into a longer name.  This isn't the only valid case.  It
is also possible to concatenate two numbers (or a number and a name,
such as `1.5' and `e3') into a number.  Also, multi-character operators
such as `+=' can be formed by concatenation.  However, two tokens that
don't together form a valid token cannot be concatenated.  For example,
concatenation of `x' on one side and `+' on the other is not meaningful
because those two tokens do not form a valid preprocessing token when
concatenated.  UNDEFINED

   Keep in mind that the C preprocessor converts comments to whitespace
before macros are even considered.  Therefore, you cannot create a
comment by concatenating `/' and `*': the `/*' sequence that starts a
comment is not a token, but rather the beginning of a comment.  You can
freely use comments next to `##' in a macro definition, or in arguments
that will be concatenated, because the comments will be converted to
spaces at first sight, and concatenation operates on tokens and so
ignores whitespace.


File: cpp.info,  Node: Undefining,  Next: Redefining,  Prev: Concatenation,  Up: Macros

Undefining Macros
-----------------

   To "undefine" a macro means to cancel its definition.  This is done
with the `#undef' directive.  `#undef' is followed by the macro name to
be undefined.

   Like definition, undefinition occurs at a specific point in the
source file, and it applies starting from that point.  The name ceases
to be a macro name, and from that point on it is treated by the
preprocessor as if it had never been a macro name.

   For example,

     #define FOO 4
     x = FOO;
     #undef FOO
     x = FOO;

expands into

     x = 4;
     
     x = FOO;

In this example, `FOO' had better be a variable or function as well as
(temporarily) a macro, in order for the result of the expansion to be
valid C code.

   The same form of `#undef' directive will cancel definitions with
arguments or definitions that don't expect arguments.  The `#undef'
directive has no effect when used on a name not currently defined as a
macro.


File: cpp.info,  Node: Redefining,  Next: Poisoning,  Prev: Undefining,  Up: Macros

Redefining Macros
-----------------

   "Redefining" a macro means defining (with `#define') a name that is
already defined as a macro.

   A redefinition is trivial if the new definition is transparently
identical to the old one.  You probably wouldn't deliberately write a
trivial redefinition, but they can happen automatically when a header
file is included more than once (*note Header Files::), so they are
accepted silently and without effect.

   Nontrivial redefinition is considered likely to be an error, so it
provokes a warning message from the preprocessor.  However, sometimes it
is useful to change the definition of a macro in mid-compilation.  You
can inhibit the warning by undefining the macro with `#undef' before
the second definition.

   In order for a redefinition to be trivial, the parameter names must
match and be in the same order, and the new replacement list must
exactly match the one already in effect, with two possible exceptions:

   * Whitespace may be added or deleted at the beginning or the end of
     the replacement list.  In a sense this is vacuous, since strictly
     such whitespace doesn't form part of the macro's expansion.

   * Between tokens in the expansion, any two forms of whitespace are
     considered equivalent.  In particular, whitespace may not be
     eliminated entirely, nor may it be added where there previously
     wasn't any.

   Recall that a comment counts as whitespace.

   As a particular case of the above, you may not redefine an
object-like macro as a function-like macro, and vice-versa.


File: cpp.info,  Node: Poisoning,  Next: Macro Pitfalls,  Prev: Redefining,  Up: Macros

Poisoning Macros
----------------

   Sometimes, there is an identifier that you want to remove completely
from your program, and make sure that it never creeps back in.  To
enforce this, the `#pragma GCC poison' directive can be used.  `#pragma
GCC poison' is followed by a list of identifiers to poison, and takes
effect for the rest of the source.  You cannot `#undef' a poisoned
identifier or test to see if it's defined with `#ifdef'.

   For example,

     #pragma GCC poison printf sprintf fprintf
     sprintf(some_string, "hello");

will produce an error.

   Note, if the poisoned identifier appears through the result of macro
expansion it _won't_ cause an error.  So if you poison an identifier
you need not worry about system headers defining macros that use it.

   For example,

     #define strrchr rindex
     #pragma GCC poison rindex
     strrchr(some_string, 'h');

will not produce an error.


File: cpp.info,  Node: Macro Pitfalls,  Prev: Poisoning,  Up: Macros

Pitfalls and Subtleties of Macros
---------------------------------

   In this section we describe some special rules that apply to macros
and macro expansion, and point out certain cases in which the rules have
counterintuitive consequences that you must watch out for.

* Menu:

* Misnesting::        Macros can contain unmatched parentheses.
* Macro Parentheses:: Why apparently superfluous parentheses
                         may be necessary to avoid incorrect grouping.
* Swallow Semicolon:: Macros that look like functions
                         but expand into compound statements.
* Side Effects::      Unsafe macros that cause trouble when
                         arguments contain side effects.
* Self-Reference::    Macros whose definitions use the macros' own names.
* Argument Prescan::  Arguments are checked for macro calls before they
                         are substituted.
* Cascaded Macros::   Macros whose definitions use other macros.
* Newlines in Args::  Sometimes line numbers get confused.


File: cpp.info,  Node: Misnesting,  Next: Macro Parentheses,  Prev: Macro Pitfalls,  Up: Macro Pitfalls

Improperly Nested Constructs
............................

   Recall that when a macro is called with arguments, the arguments are
substituted into the macro body and the result is checked, together with
the rest of the input file, for more macro calls.

   It is possible to piece together a macro call coming partially from
the macro body and partially from the arguments.  For example,

     #define double(x) (2*(x))
     #define call_with_1(x) x(1)

would expand `call_with_1 (double)' into `(2*(1))'.

   Macro definitions do not have to have balanced parentheses.  By
writing an unbalanced open parenthesis in a macro body, it is possible
to create a macro call that begins inside the macro body but ends
outside of it.  For example,

     #define strange(file) fprintf (file, "%s %d",
     ...
     strange(stderr) p, 35)

This bizarre example expands to `fprintf (stderr, "%s %d", p, 35)'!


File: cpp.info,  Node: Macro Parentheses,  Next: Swallow Semicolon,  Prev: Misnesting,  Up: Macro Pitfalls

Unintended Grouping of Arithmetic
.................................

   You may have noticed that in most of the macro definition examples
shown above, each occurrence of a macro argument name had parentheses
around it.  In addition, another pair of parentheses usually surround
the entire macro definition.  Here is why it is best to write macros
that way.

   Suppose you define a macro as follows,

     #define ceil_div(x, y) (x + y - 1) / y

whose purpose is to divide, rounding up.  (One use for this operation is
to compute how many `int' objects are needed to hold a certain number
of `char' objects.)  Then suppose it is used as follows:

     a = ceil_div (b & c, sizeof (int));

This expands into

     a = (b & c + sizeof (int) - 1) / sizeof (int);

which does not do what is intended.  The operator-precedence rules of C
make it equivalent to this:

     a = (b & (c + sizeof (int) - 1)) / sizeof (int);

What we want is this:

     a = ((b & c) + sizeof (int) - 1)) / sizeof (int);

Defining the macro as

     #define ceil_div(x, y) ((x) + (y) - 1) / (y)

provides the desired result.

   Unintended grouping can result in another way.  Consider `sizeof
ceil_div(1, 2)'.  That has the appearance of a C expression that would
compute the size of the type of `ceil_div (1, 2)', but in fact it means
something very different.  Here is what it expands to:

     sizeof ((1) + (2) - 1) / (2)

This would take the size of an integer and divide it by two.  The
precedence rules have put the division outside the `sizeof' when it was
intended to be inside.

   Parentheses around the entire macro definition can prevent such
problems.  Here, then, is the recommended way to define `ceil_div':

     #define ceil_div(x, y) (((x) + (y) - 1) / (y))


File: cpp.info,  Node: Swallow Semicolon,  Next: Side Effects,  Prev: Macro Parentheses,  Up: Macro Pitfalls

Swallowing the Semicolon
........................

   Often it is desirable to define a macro that expands into a compound
statement.  Consider, for example, the following macro, that advances a
pointer (the argument `p' says where to find it) across whitespace
characters:

     #define SKIP_SPACES(p, limit)  \
     { register char *lim = (limit); \
       while (p != lim) {            \
         if (*p++ != ' ') {          \
           p--; break; }}}

Here backslash-newline is used to split the macro definition, which must
be a single logical line, so that it resembles the way such C code would
be laid out if not part of a macro definition.

   A call to this macro might be `SKIP_SPACES (p, lim)'.  Strictly
speaking, the call expands to a compound statement, which is a complete
statement with no need for a semicolon to end it.  However, since it
looks like a function call, it minimizes confusion if you can use it
like a function call, writing a semicolon afterward, as in `SKIP_SPACES
(p, lim);'

   This can cause trouble before `else' statements, because the
semicolon is actually a null statement.  Suppose you write

     if (*p != 0)
       SKIP_SPACES (p, lim);
     else ...

The presence of two statements -- the compound statement and a null
statement -- in between the `if' condition and the `else' makes invalid
C code.

   The definition of the macro `SKIP_SPACES' can be altered to solve
this problem, using a `do ... while' statement.  Here is how:

     #define SKIP_SPACES(p, limit)     \
     do { register char *lim = (limit); \
          while (p != lim) {            \
            if (*p++ != ' ') {          \
              p--; break; }}}           \
     while (0)

   Now `SKIP_SPACES (p, lim);' expands into

     do {...} while (0);

which is one statement.


File: cpp.info,  Node: Side Effects,  Next: Self-Reference,  Prev: Swallow Semicolon,  Up: Macro Pitfalls

Duplication of Side Effects
...........................

   Many C programs define a macro `min', for "minimum", like this:

     #define min(X, Y)  ((X) < (Y) ? (X) : (Y))

   When you use this macro with an argument containing a side effect,
as shown here,

     next = min (x + y, foo (z));

it expands as follows:

     next = ((x + y) < (foo (z)) ? (x + y) : (foo (z)));

where `x + y' has been substituted for `X' and `foo (z)' for `Y'.

   The function `foo' is used only once in the statement as it appears
in the program, but the expression `foo (z)' has been substituted twice
into the macro expansion.  As a result, `foo' might be called two times
when the statement is executed.  If it has side effects or if it takes
a long time to compute, the results might not be what you intended.  We
say that `min' is an "unsafe" macro.

   The best solution to this problem is to define `min' in a way that
computes the value of `foo (z)' only once.  The C language offers no
standard way to do this, but it can be done with GNU C extensions as
follows:

     #define min(X, Y)                     \
     ({ typeof (X) __x = (X), __y = (Y);   \
        (__x < __y) ? __x : __y; })

   If you do not wish to use GNU C extensions, the only solution is to
be careful when _using_ the macro `min'.  For example, you can
calculate the value of `foo (z)', save it in a variable, and use that
variable in `min':

     #define min(X, Y)  ((X) < (Y) ? (X) : (Y))
     ...
     {
       int tem = foo (z);
       next = min (x + y, tem);
     }

(where we assume that `foo' returns type `int').


File: cpp.info,  Node: Self-Reference,  Next: Argument Prescan,  Prev: Side Effects,  Up: Macro Pitfalls

Self-Referential Macros
.......................

   A "self-referential" macro is one whose name appears in its
definition.  A special feature of ISO Standard C is that the
self-reference is not considered a macro call.  It is passed into the
preprocessor output unchanged.

   Let's consider an example:

     #define foo (4 + foo)

where `foo' is also a variable in your program.

   Following the ordinary rules, each reference to `foo' will expand
into `(4 + foo)'; then this will be rescanned and will expand into `(4
+ (4 + foo))'; and so on until it causes a fatal error (memory full) in
the preprocessor.

   However, the special rule about self-reference cuts this process
short after one step, at `(4 + foo)'.  Therefore, this macro definition
has the possibly useful effect of causing the program to add 4 to the
value of `foo' wherever `foo' is referred to.

   In most cases, it is a bad idea to take advantage of this feature.  A
person reading the program who sees that `foo' is a variable will not
expect that it is a macro as well.  The reader will come across the
identifier `foo' in the program and think its value should be that of
the variable `foo', whereas in fact the value is four greater.

   The special rule for self-reference applies also to "indirect"
self-reference.  This is the case where a macro X expands to use a
macro `y', and the expansion of `y' refers to the macro `x'.  The
resulting reference to `x' comes indirectly from the expansion of `x',
so it is a self-reference and is not further expanded.  Thus, after

     #define x (4 + y)
     #define y (2 * x)

`x' would expand into `(4 + (2 * x))'.  Clear?

   Suppose `y' is used elsewhere, not from the definition of `x'.  Then
the use of `x' in the expansion of `y' is not a self-reference because
`x' is not "in progress".  So it does expand.  However, the expansion
of `x' contains a reference to `y', and that is an indirect
self-reference now because `y' is "in progress".  The result is that
`y' expands to `(2 * (4 + y))'.

   This behavior is specified by the ISO C standard, so you may need to
understand it.


File: cpp.info,  Node: Argument Prescan,  Next: Cascaded Macros,  Prev: Self-Reference,  Up: Macro Pitfalls

Separate Expansion of Macro Arguments
.....................................

   We have explained that the expansion of a macro, including the
substituted arguments, is re-scanned for macro calls to be expanded.

   What really happens is more subtle: first each argument is scanned
separately for macro calls.  Then the resulting tokens are substituted
into the macro body to produce the macro expansion, and the macro
expansion is scanned again for macros to expand.

   The result is that the arguments are scanned _twice_ to expand macro
calls in them.

   Most of the time, this has no effect.  If the argument contained any
macro calls, they are expanded during the first scan.  The result
therefore contains no macro calls, so the second scan does not change
it.  If the argument were substituted as given, with no prescan, the
single remaining scan would find the same macro calls and produce the
same results.

   You might expect the double scan to change the results when a
self-referential macro is used in an argument of another macro (*note
Self-Reference::): the self-referential macro would be expanded once in
the first scan, and a second time in the second scan.  However, this is
not what happens.  The self-references that do not expand in the first
scan are marked so that they will not expand in the second scan either.

   The prescan is not done when an argument is stringified or
concatenated.  Thus,

     #define str(s) #s
     #define foo 4
     str (foo)

expands to `"foo"'.  Once more, prescan has been prevented from having
any noticeable effect.

   More precisely, stringification and concatenation use the argument
tokens as given without initially scanning for macros.  The same
argument would be used in expanded form if it is substituted elsewhere
without stringification or concatenation.

     #define str(s) #s lose(s)
     #define foo 4
     str (foo)

   expands to `"foo" lose(4)'.

   You might now ask, "Why mention the prescan, if it makes no
difference?  And why not skip it and make the preprocessor faster?"
The answer is that the prescan does make a difference in three special
cases:

   * Nested calls to a macro.

   * Macros that call other macros that stringify or concatenate.

   * Macros whose expansions contain unshielded commas.

   We say that "nested" calls to a macro occur when a macro's argument
contains a call to that very macro.  For example, if `f' is a macro
that expects one argument, `f (f (1))' is a nested pair of calls to
`f'.  The desired expansion is made by expanding `f (1)' and
substituting that into the definition of `f'.  The prescan causes the
expected result to happen.  Without the prescan, `f (1)' itself would
be substituted as an argument, and the inner use of `f' would appear
during the main scan as an indirect self-reference and would not be
expanded.  Here, the prescan cancels an undesirable side effect (in the
medical, not computational, sense of the term) of the special rule for
self-referential macros.

   Prescan causes trouble in certain other cases of nested macro calls.
Here is an example:

     #define foo  a,b
     #define bar(x) lose(x)
     #define lose(x) (1 + (x))
     
     bar(foo)

We would like `bar(foo)' to turn into `(1 + (foo))', which would then
turn into `(1 + (a,b))'.  Instead, `bar(foo)' expands into `lose(a,b)',
and you get an error because `lose' requires a single argument.  In
this case, the problem is easily solved by the same parentheses that
ought to be used to prevent misnesting of arithmetic operations:

     #define foo (a,b)
     #define bar(x) lose((x))

   The problem is more serious when the operands of the macro are not
expressions; for example, when they are statements.  Then parentheses
are unacceptable because they would make for invalid C code:

     #define foo { int a, b; ... }

In GNU C you can shield the commas using the `({...})' construct which
turns a compound statement into an expression:

     #define foo ({ int a, b; ... })

   Or you can rewrite the macro definition to avoid such commas:

     #define foo { int a; int b; ... }

   There is also one case where prescan is useful.  It is possible to
use prescan to expand an argument and then stringify it -- if you use
two levels of macros.  Let's add a new macro `xstr' to the example
shown above:

     #define xstr(s) str(s)
     #define str(s) #s
     #define foo 4
     xstr (foo)

   This expands into `"4"', not `"foo"'.  The reason for the difference
is that the argument of `xstr' is expanded at prescan (because `xstr'
does not specify stringification or concatenation of the argument).
The result of prescan then forms the argument for `str'.  `str' uses
its argument without prescan because it performs stringification; but
it cannot prevent or undo the prescanning already done by `xstr'.


File: cpp.info,  Node: Cascaded Macros,  Next: Newlines in Args,  Prev: Argument Prescan,  Up: Macro Pitfalls

Cascaded Use of Macros
......................

   A "cascade" of macros is when one macro's body contains a reference
to another macro.  This is very common practice.  For example,

     #define BUFSIZE 1020
     #define TABLESIZE BUFSIZE

   This is not at all the same as defining `TABLESIZE' to be `1020'.
The `#define' for `TABLESIZE' uses exactly the body you specify -- in
this case, `BUFSIZE' -- and does not check to see whether it too is the
name of a macro.

   It's only when you _use_ `TABLESIZE' that the result of its
expansion is checked for more macro names.

   This makes a difference if you change the definition of `BUFSIZE' at
some point in the source file.  `TABLESIZE', defined as shown, will
always expand using the definition of `BUFSIZE' that is currently in
effect:

     #define BUFSIZE 1020
     #define TABLESIZE BUFSIZE
     #undef BUFSIZE
     #define BUFSIZE 37

Now `TABLESIZE' expands (in two stages) to `37'.  (The `#undef' is to
prevent any warning about the nontrivial redefinition of `BUFSIZE'.)


File: cpp.info,  Node: Newlines in Args,  Prev: Cascaded Macros,  Up: Macro Pitfalls

Newlines in Macro Arguments
---------------------------

   The invocation of a function-like macro can extend over many logical
lines.  The ISO C standard requires that newlines within a macro
invocation be treated as ordinary whitespace.  This means that when the
expansion of a function-like macro replaces its invocation, it appears
on the same line as the macro name did.  Thus line numbers emitted by
the compiler or debugger refer to the line the invocation started on,
which might be different to the line containing the argument causing the
problem.

   Here is an example illustrating this:

     #define ignore_second_arg(a,b,c) a; c
     
     ignore_second_arg (foo (),
                        ignored (),
                        syntax error);

The syntax error triggered by the tokens `syntax error' results in an
error message citing line three -- the line of ignore_second_arg --
even though the problematic code comes from line five.


File: cpp.info,  Node: Conditionals,  Next: Assertions,  Prev: Macros,  Up: Top

Conditionals
============

   In a macro processor, a "conditional" is a directive that allows a
part of the program to be ignored during compilation, on some
conditions.  In the C preprocessor, a conditional can test either an
arithmetic expression or whether a name is defined as a macro.

   A conditional in the C preprocessor resembles in some ways an `if'
statement in C, but it is important to understand the difference between
them.  The condition in an `if' statement is tested during the
execution of your program.  Its purpose is to allow your program to
behave differently from run to run, depending on the data it is
operating on.  The condition in a preprocessing conditional directive is
tested when your program is compiled.  Its purpose is to allow different
code to be included in the program depending on the situation at the
time of compilation.

* Menu:

* Uses: Conditional Uses.       What conditionals are for.
* Syntax: Conditional Syntax.   How conditionals are written.
* Deletion: Deleted Code.       Making code into a comment.
* Macros: Conditionals-Macros.  Why conditionals are used with macros.
* Errors: #error Directive.     Detecting inconsistent compilation parameters.


File: cpp.info,  Node: Conditional Uses,  Next: Conditional Syntax,  Up: Conditionals

Why Conditionals are Used
-------------------------

   Generally there are three kinds of reason to use a conditional.

   * A program may need to use different code depending on the machine
     or operating system it is to run on.  In some cases the code for
     one operating system may be erroneous on another operating system;
     for example, it might refer to library routines that do not exist
     on the other system.  When this happens, it is not enough to avoid
     executing the invalid code: merely having it in the program makes
     it impossible to link the program and run it.  With a
     preprocessing conditional, the offending code can be effectively
     excised from the program when it is not valid.

   * You may want to be able to compile the same source file into two
     different programs.  Sometimes the difference between the programs
     is that one makes frequent time-consuming consistency checks on its
     intermediate data, or prints the values of those data for
     debugging, while the other does not.

   * A conditional whose condition is always false is a good way to
     exclude code from the program but keep it as a sort of comment for
     future reference.

   Most simple programs that are intended to run on only one machine
will not need to use preprocessing conditionals.


File: cpp.info,  Node: Conditional Syntax,  Next: Deleted Code,  Prev: Conditional Uses,  Up: Conditionals

Syntax of Conditionals
----------------------

   A conditional in the C preprocessor begins with a "conditional
directive": `#if', `#ifdef' or `#ifndef'.  *Note Conditionals-Macros::,
for information on `#ifdef' and `#ifndef'; only `#if' is explained here.

* Menu:

* If: #if Directive.     Basic conditionals using `#if' and `#endif'.
* Else: #else Directive. Including some text if the condition fails.
* Elif: #elif Directive. Testing several alternative possibilities.


File: cpp.info,  Node: #if Directive,  Next: #else Directive,  Up: Conditional Syntax

The `#if' Directive
...................

   The `#if' directive in its simplest form consists of

     #if EXPRESSION
     CONTROLLED TEXT
     #endif /* EXPRESSION */

   The comment following the `#endif' is not required, but it is a good
practice because it helps people match the `#endif' to the
corresponding `#if'.  Such comments should always be used, except in
short conditionals that are not nested.  In fact, you can put anything
at all after the `#endif' and it will be ignored by the GNU C
preprocessor, but only comments are acceptable in ISO Standard C.

   EXPRESSION is a C expression of integer type, subject to stringent
restrictions.  It may contain

   * Integer constants, which are all regarded as `long' or `unsigned
     long'.

   * Character constants, which are interpreted according to the
     character set and conventions of the machine and operating system
     on which the preprocessor is running.  The GNU C preprocessor uses
     the C data type `char' for these character constants; therefore,
     whether some character codes are negative is determined by the C
     compiler used to compile the preprocessor.  If it treats `char' as
     signed, then character codes large enough to set the sign bit will
     be considered negative; otherwise, no character code is considered
     negative.

   * Arithmetic operators for addition, subtraction, multiplication,
     division, bitwise operations, shifts, comparisons, and logical
     operations (`&&' and `||').  The latter two obey the usual
     short-circuiting rules of standard C.

   * Identifiers that are not macros, which are all treated as zero(!).

   * Macro calls.  All macro calls in the expression are expanded before
     actual computation of the expression's value begins.

   Note that `sizeof' operators and `enum'-type values are not allowed.
`enum'-type values, like all other identifiers that are not taken as
macro calls and expanded, are treated as zero.

   The CONTROLLED TEXT inside of a conditional can include
preprocessing directives.  Then the directives inside the conditional
are obeyed only if that branch of the conditional succeeds.  The text
can also contain other conditional groups.  However, the `#if' and
`#endif' directives must balance.


File: cpp.info,  Node: #else Directive,  Next: #elif Directive,  Prev: #if Directive,  Up: Conditional Syntax

The `#else' Directive
.....................

   The `#else' directive can be added to a conditional to provide
alternative text to be used if the condition is false.  This is what it
looks like:

     #if EXPRESSION
     TEXT-IF-TRUE
     #else /* Not EXPRESSION */
     TEXT-IF-FALSE
     #endif /* Not EXPRESSION */

   If EXPRESSION is nonzero, and thus the TEXT-IF-TRUE is active, then
`#else' acts like a failing conditional and the TEXT-IF-FALSE is
ignored.  Conversely, if the `#if' conditional fails, the TEXT-IF-FALSE
is considered included.


File: cpp.info,  Node: #elif Directive,  Prev: #else Directive,  Up: Conditional Syntax

The `#elif' Directive
.....................

   One common case of nested conditionals is used to check for more
than two possible alternatives.  For example, you might have

     #if X == 1
     ...
     #else /* X != 1 */
     #if X == 2
     ...
     #else /* X != 2 */
     ...
     #endif /* X != 2 */
     #endif /* X != 1 */

   Another conditional directive, `#elif', allows this to be
abbreviated as follows:

     #if X == 1
     ...
     #elif X == 2
     ...
     #else /* X != 2 and X != 1*/
     ...
     #endif /* X != 2 and X != 1*/

   `#elif' stands for "else if".  Like `#else', it goes in the middle
of a `#if'-`#endif' pair and subdivides it; it does not require a
matching `#endif' of its own.  Like `#if', the `#elif' directive
includes an expression to be tested.

   The text following the `#elif' is processed only if the original
`#if'-condition failed and the `#elif' condition succeeds.  More than
one `#elif' can go in the same `#if'-`#endif' group.  Then the text
after each `#elif' is processed only if the `#elif' condition succeeds
after the original `#if' and any previous `#elif' directives within it
have failed.  `#else' is equivalent to `#elif 1', and `#else' is
allowed after any number of `#elif' directives, but `#elif' may not
follow `#else'.


File: cpp.info,  Node: Deleted Code,  Next: Conditionals-Macros,  Prev: Conditional Syntax,  Up: Conditionals

Keeping Deleted Code for Future Reference
-----------------------------------------

   If you replace or delete a part of the program but want to keep the
old code around as a comment for future reference, the easy way to do
this is to put `#if 0' before it and `#endif' after it.  This is better
than using comment delimiters `/*' and `*/' since those won't work if
the code already contains comments (C comments do not nest).

   This works even if the code being turned off contains conditionals,
but they must be entire conditionals (balanced `#if' and `#endif').

   Conversely, do not use `#if 0' for comments which are not C code.
Use the comment delimiters `/*' and `*/' instead.  The interior of `#if
0' must consist of complete tokens; in particular, single-quote
characters must balance.  Comments often contain unbalanced
single-quote characters (known in English as apostrophes).  These
confuse `#if 0'.  They do not confuse `/*'.


File: cpp.info,  Node: Conditionals-Macros,  Next: #error Directive,  Prev: Deleted Code,  Up: Conditionals

Conditionals and Macros
-----------------------

   Conditionals are useful in connection with macros or assertions,
because those are the only ways that an expression's value can vary
from one compilation to another.  A `#if' directive whose expression
uses no macros or assertions is equivalent to `#if 1' or `#if 0'; you
might as well determine which one, by computing the value of the
expression yourself, and then simplify the program.

   For example, here is a conditional that tests the expression
`BUFSIZE == 1020', where `BUFSIZE' must be a macro.

     #if BUFSIZE == 1020
       printf ("Large buffers!\n");
     #endif /* BUFSIZE is large */

   (Programmers often wish they could test the size of a variable or
data type in `#if', but this does not work.  The preprocessor does not
understand `sizeof', or typedef names, or even the type keywords such
as `int'.)

   The special operator `defined' is used in `#if' and `#elif'
expressions to test whether a certain name is defined as a macro.
Either `defined NAME' or `defined (NAME)' is an expression whose value
is 1 if NAME is defined as macro at the current point in the program,
and 0 otherwise.  To the `defined' operator it makes no difference what
the definition of the macro is; all that matters is whether there is a
definition.  Thus, for example,

     #if defined (vax) || defined (ns16000)

would succeed if either of the names `vax' and `ns16000' is defined as
a macro.  You can test the same condition using assertions (*note
Assertions::), like this:

     #if #cpu (vax) || #cpu (ns16000)

   If a macro is defined and later undefined with `#undef', subsequent
use of the `defined' operator returns 0, because the name is no longer
defined.  If the macro is defined again with another `#define',
`defined' will recommence returning 1.

   If the `defined' operator appears as a result of a macro expansion,
the C standard says the behavior is undefined.  GNU cpp treats it as a
genuine `defined' operator and evaluates it normally.  It will warn
wherever your code uses this feature if you use the command-line option
`-pedantic', since other compilers may handle it differently.

   Conditionals that test whether a single macro is defined are very
common, so there are two special short conditional directives for this
case.

`#ifdef NAME'
     is equivalent to `#if defined (NAME)'.

`#ifndef NAME'
     is equivalent to `#if ! defined (NAME)'.

   Macro definitions can vary between compilations for several reasons.

   * Some macros are predefined on each kind of machine.  For example,
     on a Vax, the name `vax' is a predefined macro.  On other
     machines, it would not be defined.

   * Many more macros are defined by system header files.  Different
     systems and machines define different macros, or give them
     different values.  It is useful to test these macros with
     conditionals to avoid using a system feature on a machine where it
     is not implemented.

   * Macros are a common way of allowing users to customize a program
     for different machines or applications.  For example, the macro
     `BUFSIZE' might be defined in a configuration file for your program
     that is included as a header file in each source file.  You would
     use `BUFSIZE' in a preprocessing conditional in order to generate
     different code depending on the chosen configuration.

   * Macros can be defined or undefined with `-D' and `-U' command
     options when you compile the program.  You can arrange to compile
     the same source file into two different programs by choosing a
     macro name to specify which program you want, writing conditionals
     to test whether or how this macro is defined, and then controlling
     the state of the macro with compiler command options.  *Note
     Invocation::.

   Assertions are usually predefined, but can be defined with
preprocessor directives or command-line options.


File: cpp.info,  Node: #error Directive,  Prev: Conditionals-Macros,  Up: Conditionals

The `#error' and `#warning' Directives
--------------------------------------

   The directive `#error' causes the preprocessor to report a fatal
error.  The tokens forming the rest of the line following `#error' are
used as the error message, and not macro-expanded.  Internal whitespace
sequences are each replaced with a single space.  The line must consist
of complete tokens.

   You would use `#error' inside of a conditional that detects a
combination of parameters which you know the program does not properly
support.  For example, if you know that the program will not run
properly on a Vax, you might write

     #ifdef __vax__
     #error "Won't work on Vaxen.  See comments at get_last_object."
     #endif

*Note Nonstandard Predefined::, for why this works.

   If you have several configuration parameters that must be set up by
the installation in a consistent way, you can use conditionals to detect
an inconsistency and report it with `#error'.  For example,

     #if HASH_TABLE_SIZE % 2 == 0 || HASH_TABLE_SIZE % 3 == 0 \
         || HASH_TABLE_SIZE % 5 == 0
     #error HASH_TABLE_SIZE should not be divisible by a small prime
     #endif

   The directive `#warning' is like the directive `#error', but causes
the preprocessor to issue a warning and continue preprocessing.  The
tokens following `#warning' are used as the warning message, and not
macro-expanded.

   You might use `#warning' in obsolete header files, with a message
directing the user to the header file which should be used instead.


File: cpp.info,  Node: Assertions,  Next: Line Control,  Prev: Conditionals,  Up: Top

Assertions
==========

   "Assertions" are a more systematic alternative to macros in writing
conditionals to test what sort of computer or system the compiled
program will run on.  Assertions are usually predefined, but you can
define them with preprocessing directives or command-line options.

   The macros traditionally used to describe the type of target are not
classified in any way according to which question they answer; they may
indicate a hardware architecture, a particular hardware model, an
operating system, a particular version of an operating system, or
specific configuration options.  These are jumbled together in a single
namespace.  In contrast, each assertion consists of a named question and
an answer.  The question is usually called the "predicate".  An
assertion looks like this:

     #PREDICATE (ANSWER)

You must use a properly formed identifier for PREDICATE.  The value of
ANSWER can be any sequence of words; all characters are significant
except for leading and trailing whitespace, and differences in internal
whitespace sequences are ignored.  (This is similar to the rules
governing macro redefinition.)  Thus, `x + y' is different from `x+y'
but equivalent to ` x + y '.  `)' is not allowed in an answer.

   Here is a conditional to test whether the answer ANSWER is asserted
for the predicate PREDICATE:

     #if #PREDICATE (ANSWER)

There may be more than one answer asserted for a given predicate.  If
you omit the answer, you can test whether _any_ answer is asserted for
PREDICATE:

     #if #PREDICATE

   Most of the time, the assertions you test will be predefined
assertions.  GNU C provides three predefined predicates: `system',
`cpu', and `machine'.  `system' is for assertions about the type of
software, `cpu' describes the type of computer architecture, and
`machine' gives more information about the computer.  For example, on a
GNU system, the following assertions would be true:

     #system (gnu)
     #system (mach)
     #system (mach 3)
     #system (mach 3.SUBVERSION)
     #system (hurd)
     #system (hurd VERSION)

and perhaps others.  The alternatives with more or less version
information let you ask more or less detailed questions about the type
of system software.

   On a Unix system, you would find `#system (unix)' and perhaps one of:
`#system (aix)', `#system (bsd)', `#system (hpux)', `#system (lynx)',
`#system (mach)', `#system (posix)', `#system (svr3)', `#system
(svr4)', or `#system (xpg4)' with possible version numbers following.

   Other values for `system' are `#system (mvs)' and `#system (vms)'.

   *Portability note:* Many Unix C compilers provide only one answer
for the `system' assertion: `#system (unix)', if they support
assertions at all.  This is less than useful.

   An assertion with a multi-word answer is completely different from
several assertions with individual single-word answers.  For example,
the presence of `system (mach 3.0)' does not mean that `system (3.0)'
is true.  It also does not directly imply `system (mach)', but in GNU
C, that last will normally be asserted as well.

   The current list of possible assertion values for `cpu' is: `#cpu
(a29k)', `#cpu (alpha)', `#cpu (arm)', `#cpu (clipper)', `#cpu
(convex)', `#cpu (elxsi)', `#cpu (tron)', `#cpu (h8300)', `#cpu
(i370)', `#cpu (i386)', `#cpu (i860)', `#cpu (i960)', `#cpu (m68k)',
`#cpu (m88k)', `#cpu (mips)', `#cpu (ns32k)', `#cpu (hppa)', `#cpu
(pyr)', `#cpu (ibm032)', `#cpu (rs6000)', `#cpu (sh)', `#cpu (sparc)',
`#cpu (spur)', `#cpu (tahoe)', `#cpu (vax)', `#cpu (we32000)'.

   You can create assertions within a C program using `#assert', like
this:

     #assert PREDICATE (ANSWER)

(Note the absence of a `#' before PREDICATE.)

   Each time you do this, you assert a new true answer for PREDICATE.
Asserting one answer does not invalidate previously asserted answers;
they all remain true.  The only way to remove an answer is with
`#unassert'.  `#unassert' has the same syntax as `#assert'.  You can
also remove all answers to a PREDICATE like this:

     #unassert PREDICATE

   You can also add or cancel assertions using command options when you
run `gcc' or `cpp'.  *Note Invocation::.


File: cpp.info,  Node: Line Control,  Next: Other Directives,  Prev: Assertions,  Up: Top

Combining Source Files
======================

   One of the jobs of the C preprocessor is to inform the C compiler of
where each line of C code came from: which source file and which line
number.

   C code can come from multiple source files if you use `#include';
both `#include' and the use of conditionals and macros can cause the
line number of a line in the preprocessor output to be different from
the line's number in the original source file.  You will appreciate the
value of making both the C compiler (in error messages) and symbolic
debuggers such as GDB use the line numbers in your source file.

   The C preprocessor builds on this feature by offering a directive by
which you can control the feature explicitly.  This is useful when a
file for input to the C preprocessor is the output from another program
such as the `bison' parser generator, which operates on another file
that is the true source file.  Parts of the output from `bison' are
generated from scratch, other parts come from a standard parser file.
The rest are copied nearly verbatim from the source file, but their
line numbers in the `bison' output are not the same as their original
line numbers.  Naturally you would like compiler error messages and
symbolic debuggers to know the original source file and line number of
each line in the `bison' input.

   `bison' arranges this by writing `#line' directives into the output
file.  `#line' is a directive that specifies the original line number
and source file name for subsequent input in the current preprocessor
input file.  `#line' has three variants:

`#line LINENUM'
     Here LINENUM is a decimal integer constant.  This specifies that
     the line number of the following line of input, in its original
     source file, was LINENUM.

`#line LINENUM FILENAME'
     Here LINENUM is a decimal integer constant and FILENAME is a
     string constant.  This specifies that the following line of input
     came originally from source file FILENAME and its line number
     there was LINENUM.  Keep in mind that FILENAME is not just a file
     name; it is surrounded by double-quote characters so that it looks
     like a string constant.

`#line ANYTHING ELSE'
     ANYTHING ELSE is checked for macro calls, which are expanded.  The
     result should be a decimal integer constant followed optionally by
     a string constant, as described above.

   `#line' directives alter the results of the `__FILE__' and
`__LINE__' predefined macros from that point on.  *Note Standard
Predefined::.

   The output of the preprocessor (which is the input for the rest of
the compiler) contains directives that look much like `#line'
directives.  They start with just `#' instead of `#line', but this is
followed by a line number and file name as in `#line'.  *Note Output::.

